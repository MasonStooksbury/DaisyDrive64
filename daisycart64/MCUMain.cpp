#define DEBUG_DEFAULT_INTERRUPT_HANDLERS 1
#include <stdio.h>
#include <string.h>
#include "daisy_seed.h"
#include "fatfs.h"
#include "stm32h7xx_hal.h"
#include "sys/system.h"
#include "stm32h7xx_hal_dma.h"

#ifndef _FS_EXFAT
#error FAT FS NEEDS TO BE ENABLED
#endif

__IO   uint32_t DMA_TransferErrorFlag = 0;
DMA_HandleTypeDef DMA_Handle_Channel0;
DMA_HandleTypeDef DMA_Handle_Channel1;

// Generated by BreakPoint Software's Hex Workshop v6.7.3.5308
//   http://www.hexworkshop.com
//   http://www.bpsoft.com
//
//  Source File: C:\test\Super Mario 64 (USA).n64
//         Time: 8/16/2022 10:26 PM
// Orig. Offset: 0 / 0x00000000
//       Length: 1281 / 0x00000501 (bytes)
unsigned char rawData[1281] =
{
    //0x37, 0x80, 0x40, 0x12, 0x00, 0x00, 0x0F, 0x00, 0x24, 0x80, 0x00, 0x60, 0x00, 0x00, 0x44, 0x14, 
    0x37, 0x80, 0x40, 0x20, 0x00, 0x00, 0x0F, 0x00, 0x24, 0x80, 0x00, 0x60, 0x00, 0x00, 0x44, 0x14, 
    //0x37, 0x80, 0x40, 0xFF, 0x00, 0x00, 0x0F, 0x00, 0x24, 0x80, 0x00, 0x60, 0x00, 0x00, 0x44, 0x14, 
    //1 0-7 8-16  2 0-7 8-16
    //0xFF, 0x01, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00, 
    0x5A, 0x63, 0xFF, 0x2B, 0x02, 0x8B, 0x26, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x55, 0x53, 0x45, 0x50, 0x20, 0x52, 0x41, 0x4D, 0x49, 0x52, 0x20, 0x4F, 0x34, 0x36, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x4D, 0x53, 0x00, 0x45, 
    0x80, 0x40, 0x00, 0x68, 0x80, 0x40, 0x00, 0x48, 0x80, 0x40, 0x00, 0x58, 0x08, 0x3C, 0x70, 0xA4, 
    0x08, 0x25, 0x00, 0x00, 0x09, 0x8D, 0x0C, 0x00, 0x20, 0x15, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xBD, 0x27, 0xE8, 0xFF, 0xB3, 0xAF, 0x00, 0x00, 0xB4, 0xAF, 0x04, 0x00, 0xB5, 0xAF, 0x08, 0x00, 
    0xB6, 0xAF, 0x0C, 0x00, 0xB7, 0xAF, 0x10, 0x00, 0x08, 0x3C, 0x70, 0xA4, 0x08, 0x25, 0x00, 0x00, 
    0x0A, 0x3C, 0xF8, 0xA3, 0x0B, 0x3C, 0xF0, 0xA3, 0x0C, 0x3C, 0x30, 0xA4, 0x8C, 0x25, 0x00, 0x00, 
    0x09, 0x34, 0x40, 0x00, 0x09, 0xAD, 0x04, 0x00, 0x11, 0x24, 0x40, 0x1F, 0x00, 0x00, 0x00, 0x00, 
    0x31, 0x22, 0xFF, 0xFF, 0x20, 0x16, 0xFD, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAD, 0x08, 0x00, 
    0x09, 0x34, 0x14, 0x00, 0x09, 0xAD, 0x0C, 0x00, 0x00, 0xAD, 0x00, 0x00, 0x11, 0x24, 0x04, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x31, 0x22, 0xFF, 0xFF, 0x20, 0x16, 0xFD, 0xFF, 0x00, 0x00, 0x00, 0x00, 
    0x09, 0x34, 0x0E, 0x00, 0x09, 0xAD, 0x00, 0x00, 0x11, 0x24, 0x20, 0x00, 0x31, 0x22, 0xFF, 0xFF, 
    0x20, 0x16, 0xFE, 0xFF, 0x09, 0x34, 0x0F, 0x01, 0x89, 0xAD, 0x00, 0x00, 0x09, 0x3C, 0x08, 0x18, 
    0x29, 0x35, 0x38, 0x28, 0x49, 0xAD, 0x08, 0x00, 0x40, 0xAD, 0x14, 0x00, 0x09, 0x3C, 0x00, 0x80, 
    0x49, 0xAD, 0x04, 0x00, 0x00, 0x00, 0x25, 0x68, 0x00, 0x00, 0x25, 0x70, 0x0F, 0x3C, 0xF0, 0xA3, 
    0x00, 0x00, 0x25, 0xC0, 0x19, 0x3C, 0xF0, 0xA3, 0x16, 0x3C, 0x00, 0xA0, 0x00, 0x00, 0x25, 0xB8, 
    0x06, 0x3C, 0xF0, 0xA3, 0x07, 0x3C, 0x00, 0xA0, 0x00, 0x00, 0x25, 0x90, 0x14, 0x3C, 0x00, 0xA0, 
    0xBD, 0x27, 0xB8, 0xFF, 0xA0, 0x03, 0x25, 0xF0, 0x10, 0x3C, 0x30, 0xA4, 0x10, 0x8E, 0x04, 0x00, 
    0x11, 0x3C, 0x01, 0x01, 0x31, 0x26, 0x01, 0x01, 0x11, 0x16, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x10, 0x24, 0x00, 0x02, 0x71, 0x35, 0x00, 0x40, 0x00, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x10, 0x24, 0x00, 0x04, 0x71, 0x35, 0x00, 0x80, 0x2E, 0xAE, 0x04, 0x00, 0xF5, 0x25, 0x0C, 0x00, 
    0x00, 0x0D, 0xDE, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xA2, 0xAF, 0x00, 0x00, 0x09, 0x24, 0x00, 0x20, 0x89, 0xAD, 0x00, 0x00, 0xEB, 0x8D, 0x00, 0x00, 
    0x08, 0x3C, 0xFF, 0xF0, 0x68, 0x01, 0x24, 0x58, 0xAB, 0xAF, 0x04, 0x00, 0xBD, 0x23, 0x08, 0x00, 
    0x09, 0x24, 0x00, 0x10, 0x89, 0xAD, 0x00, 0x00, 0x08, 0x3C, 0x19, 0xB0, 0x68, 0x15, 0x0C, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x08, 0x3C, 0x00, 0x08, 0x08, 0x03, 0x20, 0xC0, 0x30, 0x03, 0x20, 0xC8, 
    0x30, 0x03, 0x20, 0xC8, 0x08, 0x3C, 0x20, 0x00, 0xC8, 0x02, 0x20, 0xB0, 0x88, 0x02, 0x20, 0xA0, 
    0x12, 0x00, 0x40, 0x90, 0x52, 0x22, 0x01, 0x00, 0x00, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x08, 0x3C, 0x10, 0x00, 0x88, 0x02, 0x20, 0xA0, 0x08, 0x24, 0x00, 0x20, 0x88, 0xAD, 0x00, 0x00, 
    0xE9, 0x8D, 0x24, 0x00, 0xFA, 0x8D, 0x00, 0x00, 0x08, 0x24, 0x00, 0x10, 0x88, 0xAD, 0x00, 0x00, 
    0x29, 0x31, 0xFF, 0xFF, 0x08, 0x24, 0x00, 0x05, 0x28, 0x15, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x1B, 0x3C, 0x00, 0x01, 0x5B, 0x03, 0x24, 0xD0, 0x40, 0x17, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x08, 0x3C, 0x1C, 0x10, 0x08, 0x35, 0x04, 0x0A, 0xE8, 0xAD, 0x18, 0x00, 0x00, 0x10, 0x03, 0x00, 
    0x08, 0x3C, 0x0C, 0x08, 0x08, 0x35, 0x04, 0x12, 0xE8, 0xAD, 0x18, 0x00, 0x08, 0x3C, 0x00, 0x08, 
    0xC8, 0x01, 0x20, 0x70, 0xF0, 0x01, 0x20, 0x78, 0xF0, 0x01, 0x20, 0x78, 0xAD, 0x25, 0x01, 0x00, 
    0xA8, 0x2D, 0x08, 0x00, 0x00, 0x15, 0xC4, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x08, 0x3C, 0x00, 0xC4, 
    0x48, 0xAD, 0x0C, 0x00, 0x08, 0x3C, 0x00, 0x80, 0x48, 0xAD, 0x04, 0x00, 0xC0, 0x03, 0x25, 0xE8, 
    0x00, 0x00, 0x25, 0x18, 0xA9, 0x8F, 0x04, 0x00, 0x08, 0x3C, 0x09, 0xB0, 0x28, 0x15, 0x16, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x38, 0xAE, 0x04, 0x00, 0x35, 0x27, 0x0C, 0x00, 0xA4, 0x8F, 0x00, 0x00, 
    0xBD, 0x23, 0x08, 0x00, 0x05, 0x24, 0x01, 0x00, 0x00, 0x0D, 0x90, 0x02, 0x00, 0x00, 0x00, 0x00, 
    0xC8, 0x8E, 0x00, 0x00, 0x08, 0x3C, 0x08, 0x00, 0x16, 0x01, 0x20, 0x40, 0x09, 0x8D, 0x00, 0x00, 
    0xC8, 0x8E, 0x00, 0x00, 0x08, 0x3C, 0x08, 0x00, 0x16, 0x01, 0x20, 0x40, 0x09, 0x8D, 0x00, 0x00, 
    0x08, 0x3C, 0x00, 0x04, 0xC8, 0x01, 0x20, 0x70, 0x30, 0x03, 0x20, 0xC8, 0x08, 0x3C, 0x10, 0x00, 
    0xC8, 0x02, 0x20, 0xB0, 0x00, 0x10, 0x21, 0x00, 0x37, 0xAE, 0x04, 0x00, 0xD5, 0x24, 0x0C, 0x00, 
    0xA4, 0x8F, 0x00, 0x00, 0xBD, 0x23, 0x08, 0x00, 0x05, 0x24, 0x01, 0x00, 0x00, 0x0D, 0x90, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0xE8, 0x8C, 0x00, 0x00, 0x08, 0x3C, 0x08, 0x00, 0x07, 0x01, 0x20, 0x40, 
    0x09, 0x8D, 0x00, 0x00, 0x08, 0x3C, 0x10, 0x00, 0x07, 0x01, 0x20, 0x40, 0x09, 0x8D, 0x00, 0x00, 
    0x08, 0x3C, 0x18, 0x00, 0x07, 0x01, 0x20, 0x40, 0x09, 0x8D, 0x00, 0x00, 0xE8, 0x8C, 0x00, 0x00, 
    0x08, 0x3C, 0x08, 0x00, 0x07, 0x01, 0x20, 0x40, 0x09, 0x8D, 0x00, 0x00, 0x08, 0x3C, 0x10, 0x00, 
    0x07, 0x01, 0x20, 0x40, 0x09, 0x8D, 0x00, 0x00, 0x08, 0x3C, 0x18, 0x00, 0x07, 0x01, 0x20, 0x40, 
    0x09, 0x8D, 0x00, 0x00, 0x08, 0x3C, 0x00, 0x08, 0xE8, 0x02, 0x20, 0xB8, 0xD0, 0x00, 0x20, 0x30, 
    0xD0, 0x00, 0x20, 0x30, 0x08, 0x3C, 0x20, 0x00, 0xE8, 0x00, 0x20, 0x38, 0x63, 0x24, 0x01, 0x00, 
    0x6D, 0x00, 0x2A, 0x40, 0x00, 0x15, 0xC3, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x3C, 0x70, 0xA4, 
    0x12, 0x00, 0xC0, 0x94, 0x09, 0x3C, 0x06, 0x00, 0x29, 0x35, 0x34, 0x36, 0x32, 0x01, 0x25, 0x48, 
    0x49, 0xAD, 0x10, 0x00, 0x49, 0x8D, 0x10, 0x00, 0x08, 0x3C, 0x00, 0xA0, 0x08, 0x35, 0x00, 0x03, 
    0x09, 0x3C, 0xFF, 0x0F, 0x29, 0x35, 0xFF, 0xFF, 0xC9, 0x02, 0x24, 0xB0, 0x16, 0xAD, 0x18, 0x00, 
    0xC0, 0x03, 0x25, 0xE8, 0xBD, 0x27, 0x48, 0x00, 0xB3, 0x8F, 0x00, 0x00, 0xB4, 0x8F, 0x04, 0x00, 
    0xB5, 0x8F, 0x08, 0x00, 0xB6, 0x8F, 0x0C, 0x00, 0xB7, 0x8F, 0x10, 0x00, 0xBD, 0x27, 0x18, 0x00, 
    0x08, 0x3C, 0x00, 0x80, 0x08, 0x25, 0x00, 0x00, 0x09, 0x25, 0x00, 0x40, 0x29, 0x25, 0xE0, 0xFF, 
    0x80, 0x40, 0x00, 0xE0, 0x80, 0x40, 0x00, 0xE8, 0x08, 0xBD, 0x00, 0x00, 0x09, 0x01, 0x2B, 0x08, 
    0x20, 0x14, 0xFD, 0xFF, 0x08, 0x25, 0x20, 0x00, 0x08, 0x3C, 0x00, 0x80, 0x08, 0x25, 0x00, 0x00, 
    0x09, 0x25, 0x00, 0x20, 0x29, 0x25, 0xF0, 0xFF, 0x09, 0xBD, 0x00, 0x00, 0x09, 0x01, 0x2B, 0x08, 
    0x20, 0x14, 0xFD, 0xFF, 0x08, 0x25, 0x10, 0x00, 0x00, 0x10, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x08, 0x3C, 0x00, 0x80, 0x08, 0x25, 0x00, 0x00, 0x09, 0x25, 0x00, 0x40, 0x29, 0x25, 0xE0, 0xFF, 
    0x80, 0x40, 0x00, 0xE0, 0x80, 0x40, 0x00, 0xE8, 0x08, 0xBD, 0x00, 0x00, 0x09, 0x01, 0x2B, 0x08, 
    0x20, 0x14, 0xFD, 0xFF, 0x08, 0x25, 0x20, 0x00, 0x08, 0x3C, 0x00, 0x80, 0x08, 0x25, 0x00, 0x00, 
    0x09, 0x25, 0x00, 0x20, 0x29, 0x25, 0xF0, 0xFF, 0x01, 0xBD, 0x00, 0x00, 0x09, 0x01, 0x2B, 0x08, 
    0x20, 0x14, 0xFD, 0xFF, 0x08, 0x25, 0x10, 0x00, 0x0A, 0x3C, 0x00, 0xA4, 0x4A, 0x25, 0x00, 0x00, 
    0x0B, 0x3C, 0xF0, 0xFF, 0x09, 0x3C, 0x10, 0x00, 0x4B, 0x01, 0x24, 0x50, 0x08, 0x3C, 0x00, 0xA4, 
    0x29, 0x25, 0xFF, 0xFF, 0x0B, 0x3C, 0x00, 0xA4, 0x08, 0x25, 0xC0, 0x04, 0x6B, 0x25, 0x74, 0x07, 
    0x09, 0x01, 0x24, 0x40, 0x69, 0x01, 0x24, 0x58, 0x09, 0x3C, 0x00, 0xA0, 0x0A, 0x01, 0x25, 0x40, 
    0x6A, 0x01, 0x25, 0x58, 0x29, 0x25, 0x00, 0x00, 0x0D, 0x8D, 0x00, 0x00, 0x08, 0x25, 0x04, 0x00, 
    0x0B, 0x01, 0x2B, 0x08, 0x29, 0x25, 0x04, 0x00, 0x20, 0x14, 0xFB, 0xFF, 0x2D, 0xAD, 0xFC, 0xFF, 
    0x0C, 0x3C, 0x00, 0x80, 0x8C, 0x25, 0x00, 0x00, 0x80, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0B, 0x3C, 0x00, 0xB0, 0x69, 0x8D, 0x08, 0x00, 0x0A, 0x3C, 0xFF, 0x1F, 0x4A, 0x35, 0xFF, 0xFF, 
    0x01, 0x3C, 0x60, 0xA4, 0x2A, 0x01, 0x24, 0x48, 0x29, 0xAC, 0x00, 0x00, 0x08, 0x3C, 0x60, 0xA4, 
    0x08, 0x8D, 0x10, 0x00, 0x08, 0x31, 0x02, 0x00, 0x00, 0x55, 0xFD, 0xFF, 0x08, 0x3C, 0x60, 0xA4, 
    0x08, 0x24, 0x00, 0x10, 0x0B, 0x01, 0x20, 0x40, 0x0A, 0x01, 0x24, 0x40, 0x01, 0x3C, 0x60, 0xA4, 
0x28, 
} ;


//#define MENU_ROM_FILE_NAME "menu.z64"
#define MENU_ROM_FILE_NAME "Super Mario 64 (USA).n64"
//#define MENU_ROM_FILE_NAME "Resident Evil 2 (USA).n64"

#define N64_ROM_BASE 0x10000000
using namespace daisy;
BYTE *Sram4Buffer = (BYTE*)0x38000000;
int8_t *ram = (int8_t *)0xC0000000;
uint32_t *LogBuffer = (uint32_t*)(ram + (8*1024*1024));
uint32_t *PortABuffer = (uint32_t*)Sram4Buffer;
uint32_t *PortBBuffer = (uint32_t*)(Sram4Buffer + 16);

static DaisySeed hw;

SdmmcHandler   sd;
FatFSInterface fsi;
FIL            SDFile;

void BlinkAndDie(int wait1, int wait2)
{
    while(1) {
        GPIOC->BSRR = (0x1 << 7);
        System::Delay(wait1);
        GPIOC->BSRR = (0x1 << 7) << 16;
        System::Delay(wait2);
    }
}

#define GP_SPEED GPIO_SPEED_FREQ_VERY_HIGH
uint32_t ADInputAddress = 0;
uint32_t PrefetchRead = 0;
uint32_t ReadOffset = 0;
uint32_t ReadCount = 0;
static void HAL_TransferError(DMA_HandleTypeDef *hdma);
static void Error_Handler(void);

int InitializeDmaChannels(void)
{
    HAL_DMA_MuxRequestGeneratorConfigTypeDef dmamux_ReqGenParams  = {0};

    /*##-2- Configure the DMA ##################################################*/
    /* Enable BDMA clock */
    __HAL_RCC_BDMA_CLK_ENABLE();

    { // Channel 0 init.
        /* Configure the DMA handler for Transmission process     */
        /* DMA mode is set to circular for an infinite DMA transfer */
        DMA_Handle_Channel0.Instance                 = BDMA_Channel0;
        DMA_Handle_Channel0.Init.Request             = BDMA_REQUEST_GENERATOR0;
        DMA_Handle_Channel0.Init.Direction           = DMA_PERIPH_TO_MEMORY;
        DMA_Handle_Channel0.Init.PeriphInc           = DMA_PINC_DISABLE;
        DMA_Handle_Channel0.Init.MemInc              = DMA_MINC_DISABLE;
        DMA_Handle_Channel0.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
        DMA_Handle_Channel0.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
        DMA_Handle_Channel0.Init.Mode                = DMA_CIRCULAR;
        DMA_Handle_Channel0.Init.Priority            = DMA_PRIORITY_VERY_HIGH;
        DMA_Handle_Channel0.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
        DMA_Handle_Channel0.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_HALFFULL;
        DMA_Handle_Channel0.Init.MemBurst            = DMA_MBURST_SINGLE;
        DMA_Handle_Channel0.Init.PeriphBurst         = DMA_PBURST_SINGLE;

        /* Initialize the DMA with for Transmission process */
        HAL_StatusTypeDef dmares = HAL_OK;
        dmares = HAL_DMA_Init(&DMA_Handle_Channel0);
        if (dmares != HAL_OK) {
            Error_Handler();
        }

        /* Select Callbacks functions called after Transfer complete and Transfer error */
        dmares = HAL_DMA_RegisterCallback(&DMA_Handle_Channel0, HAL_DMA_XFER_CPLT_CB_ID, NULL);
        if (dmares != HAL_OK) {
            Error_Handler();
        }
        dmares = HAL_DMA_RegisterCallback(&DMA_Handle_Channel0, HAL_DMA_XFER_ERROR_CB_ID, HAL_TransferError);
        if (dmares != HAL_OK) {
            Error_Handler();
        }

                /* NVIC configuration for DMA transfer complete interrupt*/
        HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
        HAL_NVIC_EnableIRQ(BDMA_Channel0_IRQn);

        /*##-3- Configure and enable the DMAMUX Request generator  ####################*/
        dmamux_ReqGenParams.SignalID  = HAL_DMAMUX2_REQ_GEN_EXTI0; /* External request signal is LPTIM2 signal */
        dmamux_ReqGenParams.Polarity  = HAL_DMAMUX_REQ_GEN_RISING;      /* External request signal edge is Rising  */
        dmamux_ReqGenParams.RequestNumber = 1;                          /* 1 requests on each edge of the external request signal  */
        //dmamux_ReqGenParams.RequestNumber = 2;                          /* 1 requests on each edge of the external request signal  */

        dmares = HAL_DMAEx_ConfigMuxRequestGenerator(&DMA_Handle_Channel0, &dmamux_ReqGenParams);
        if (dmares != HAL_OK) {
            Error_Handler();
        }

        /* NVIC configuration for DMAMUX request generator overrun errors*/
        HAL_NVIC_SetPriority(DMAMUX2_OVR_IRQn, 0, 0);
        HAL_NVIC_EnableIRQ(DMAMUX2_OVR_IRQn);

        dmares = HAL_DMAEx_EnableMuxRequestGenerator (&DMA_Handle_Channel0);
        if (dmares != HAL_OK) {
            Error_Handler();
        }

        dmares = HAL_DMA_Start_IT(&DMA_Handle_Channel0, (uint32_t)&(GPIOA->IDR), (uint32_t)(Sram4Buffer), 4);
        //dmares = HAL_DMA_Start_IT(&DMA_Handle_Channel0, (uint32_t)(Sram4Buffer + 8), (uint32_t)&(GPIOA->ODR), 8);
        if (dmares != HAL_OK) {
            Error_Handler();
        }
    }

    { // Channel 1 init.
        /* Configure the DMA handler for Transmission process     */
        /* DMA mode is set to circular for an infinite DMA transfer */
        DMA_Handle_Channel1.Instance                 = BDMA_Channel1;
        DMA_Handle_Channel1.Init.Request             = BDMA_REQUEST_GENERATOR0;
        DMA_Handle_Channel1.Init.Direction           = DMA_PERIPH_TO_MEMORY;
        DMA_Handle_Channel1.Init.PeriphInc           = DMA_PINC_DISABLE;
        DMA_Handle_Channel1.Init.MemInc              = DMA_MINC_DISABLE;
        DMA_Handle_Channel1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
        DMA_Handle_Channel1.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
        DMA_Handle_Channel1.Init.Mode                = DMA_CIRCULAR;
        DMA_Handle_Channel1.Init.Priority            = DMA_PRIORITY_VERY_HIGH;
        DMA_Handle_Channel1.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
        DMA_Handle_Channel1.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_HALFFULL;
        DMA_Handle_Channel1.Init.MemBurst            = DMA_MBURST_SINGLE;
        DMA_Handle_Channel1.Init.PeriphBurst         = DMA_PBURST_SINGLE;

        /* Initialize the DMA with for Transmission process */
        HAL_StatusTypeDef dmares = HAL_OK;
        dmares = HAL_DMA_Init(&DMA_Handle_Channel1);
        if (dmares != HAL_OK) {
            Error_Handler();
        }

        /* Select Callbacks functions called after Transfer complete and Transfer error */
        dmares = HAL_DMA_RegisterCallback(&DMA_Handle_Channel1, HAL_DMA_XFER_CPLT_CB_ID, NULL);
        if (dmares != HAL_OK) {
            Error_Handler();
        }
        dmares = HAL_DMA_RegisterCallback(&DMA_Handle_Channel1, HAL_DMA_XFER_ERROR_CB_ID, HAL_TransferError);
        if (dmares != HAL_OK) {
            Error_Handler();
        }

        /* NVIC configuration for DMA transfer complete interrupt*/
        HAL_NVIC_SetPriority(BDMA_Channel1_IRQn, 0, 0);
        HAL_NVIC_EnableIRQ(BDMA_Channel1_IRQn);

        /*##-3- Configure and enable the DMAMUX Request generator  ####################*/
        dmamux_ReqGenParams.SignalID  = HAL_DMAMUX2_REQ_GEN_EXTI0;
        dmamux_ReqGenParams.Polarity  = HAL_DMAMUX_REQ_GEN_RISING;
        dmamux_ReqGenParams.RequestNumber = 1;

        dmares = HAL_DMAEx_ConfigMuxRequestGenerator(&DMA_Handle_Channel1, &dmamux_ReqGenParams);
        if (dmares != HAL_OK) {
            Error_Handler();
        }

        /* NVIC configuration for DMAMUX request generator overrun errors*/
        HAL_NVIC_SetPriority(DMAMUX2_OVR_IRQn, 0, 0);
        HAL_NVIC_EnableIRQ(DMAMUX2_OVR_IRQn);

        dmares = HAL_DMAEx_EnableMuxRequestGenerator (&DMA_Handle_Channel1);
        if (dmares != HAL_OK) {
            Error_Handler();
        }

        volatile uint32_t dmares1 = HAL_DMA_Start_IT(&DMA_Handle_Channel1, (uint32_t)&(GPIOB->IDR), (uint32_t)(PortBBuffer), 4);
        if (dmares1 != HAL_OK) {
            Error_Handler();
        }
    }

    return 0;
}

static void HAL_TransferError(DMA_HandleTypeDef *hdma)
{
  DMA_TransferErrorFlag = 1;
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
static void Error_Handler(void)
{
    GPIOC->BSRR = (0x1 << 7);
  while(1)
  {
  }
}

#define ALE_L (1 << 0)
#define READ_LINE (1 << 1)
#define ALE_H (1 << 11)

#define ALE_H_IS_HIGH ((GPIOD->IDR & ALE_H) != 0)
#define ALE_H_IS_LOW ((GPIOD->IDR & ALE_H) == 0)
#define ALE_L_IS_HIGH ((GPIOC->IDR & ALE_L) != 0)
#define ALE_L_IS_LOW ((GPIOC->IDR & ALE_L) == 0)
#define READ_IS_HIGH ((GPIOC->IDR & READ_LINE) != 0)
#define READ_IS_LOW ((GPIOC->IDR & READ_LINE) == 0)


uint32_t HighB;
uint32_t HighA;
uint32_t LowB;
uint32_t LowA;

typedef struct
{
  __IO uint32_t ISR;   /*!< BDMA interrupt status register */
  __IO uint32_t IFCR;  /*!< BDMA interrupt flag clear register */
} BDMA_Base_Registers;
const uint32_t StreamBaseAddress = (0x58025400UL);

#ifdef DMA_SOLUTION
typedef struct
{
  __IO uint32_t ISR;   /*!< BDMA interrupt status register */
  __IO uint32_t IFCR;  /*!< BDMA interrupt flag clear register */
} BDMA_Base_Registers;
//const uint32_t *StreamBaseAddress = 0x58025400;

volatile uint32_t Channel0IntCount = 0;
volatile uint32_t Channel1IntCount = 0;
volatile uint32_t ALE_L_InterruptCount = 0;
extern "C" void BDMA_Channel0_IRQHandler(void)
{
    // Stuff the read values into real memory.
    // On rising edge stuff into HighB and HighA
    // On falling edge stuff into LowB and LowA

    //BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
    //regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
    //regs_bdma->IFCR = 2 << 0;
    // TODO: reduce directly to address. 0x58025400
    ((BDMA_Base_Registers *)(DMA_Handle_Channel0.StreamBaseAddress))->IFCR = (2 << 0);
    if ((ALE_L_InterruptCount & 1) == 0) {
        LowA = *((uint32_t*)Sram4Buffer);
    } else {
        HighA = *((uint32_t*)Sram4Buffer);
    }
    Channel0IntCount += 1;
}

extern "C" void BDMA_Channel1_IRQHandler(void)
{
    //regs_bdma->IFCR = 2 << 1;
    ((BDMA_Base_Registers *)(DMA_Handle_Channel1.StreamBaseAddress))->IFCR = (2 << 4);

    // Stuff the read values into real memory.
    // On rising edge stuff into HighB and HighA
    // On falling edge stuff into LowB and LowA
    if ((ALE_L_InterruptCount & 1) == 0) {
        LowB = *((uint32_t*)Sram4Buffer+16);
    } else {
        HighB = *((uint32_t*)Sram4Buffer+16);
    }
    
    Channel1IntCount += 1;
}

inline void GetAddress(void)
{
    ADInputAddress = (LowA & 0xFF) | ((LowB & 0x03F0) << 4) | (LowB & 0xC000) |
                     (((HighA & 0xFF) | ((HighB & 0x03F0) << 4) | (HighB & 0xC000)) << 16);
}

extern "C" void EXTI0_IRQHandler(void)
{
    EXTI->PR1 = 1;
    ReadOffset = 0; // Reset the read offset.
    // No work here yet, could figure out if the ALE_H was up or not during rising.
    ALE_L_InterruptCount += 1;
}

extern "C" void EXTI1_IRQHandler(void)
{
    // Clear Pending interrupt bit
    EXTI->PR1 = 2;

    while ((Channel1IntCount & 2) == 0) {}

    GPIOA->MODER = 0xABFF5555;
    GPIOB->MODER = 0x5CB555B3;

    // Get the address.
    if (ReadOffset == 0) {
        GetAddress();
        PrefetchRead = *((uint32_t*)(ram + (ADInputAddress - N64_ROM_BASE)));
    }

    // Output the half word.
    uint32_t Value = (((ReadOffset & 2) == 0) ? PrefetchRead : (PrefetchRead >> 16));
    uint32_t OutB = (((Value >> 4) & 0x03F0) | (Value & 0xC000));
    GPIOA->ODR = (Value & 0xFF);
    GPIOB->ODR = OutB;
    ReadOffset += 2;
    if ((ReadOffset & 3) == 0) {
        //if ((ADInputAddress >= N64_ROM_BASE) && (ADInputAddress < (N64_ROM_BASE + (64 * 1024 * 1024)))) {
            PrefetchRead = *((uint32_t*)(ram + (ADInputAddress - N64_ROM_BASE) + ReadOffset));
        //}
    }

    //GPIOA->MODER &= 0xFFFF0008;
    LogBuffer[ReadCount] = ADInputAddress;
    ReadCount += 1;

    if (ReadOffset == 512) {
        ReadOffset = 0;
    }
        // Wait for READ high and set the mode.
        //while ((GPIOC->IDR & 1) == 0) {}
        //GPIOA->MODER &= 0xFFFF0000;
        //GPIOB->MODER &= 0x0FF000FF;
        while (READ_IS_LOW) {}
        GPIOA->MODER = 0xABFF0000;
        GPIOB->MODER = 0x0CB000B3;
        //GPIOC->BSRR = 2 << 16;
    //}
}

#else // NON DMA

uint32_t A[2];
uint32_t B[2];
volatile uint32_t DMACount = 0;
volatile uint32_t DMACount1 = 0;
uint32_t ALELCount = 0;
volatile uint32_t reads = 0;
extern "C" void EXTI0_IRQHandler(void)
{
    const uint32_t b = GPIOB->IDR;
    const uint32_t a = GPIOA->IDR;
    __DSB();
    EXTI->PR1 = 1;
    B[ALELCount & 1] = b;
    A[ALELCount & 1] = a;
    ALELCount += 1;
    
}

uint32_t SaveA[512];
uint32_t SaveB[512];
volatile int a = 0;
extern "C" void BDMA_Channel1_IRQHandler(void)
{
    ((BDMA_Base_Registers *)(DMA_Handle_Channel0.StreamBaseAddress))->IFCR = (2 << 4);
    //B[0] = *((uint32_t*)(Sram4Buffer + 16));
    //A[0] = *Sram4Buffer;
    DMACount1 += 1;
}

extern "C" void BDMA_Channel0_IRQHandler(void)
{
    ((BDMA_Base_Registers *)(DMA_Handle_Channel0.StreamBaseAddress))->IFCR = (2 << 0);
    //B[x & 1] = *((uint32_t*)(Sram4Buffer + 16));
    //A[x & 1] = *Sram4Buffer;
    B[0] = *((uint32_t*)(Sram4Buffer + 16));
    A[0] = *Sram4Buffer;
    //DMACount += 1;
    DMACount += 1;
}

volatile uint32_t IntCount = 0;
volatile uint32_t OutCount = 0;
extern "C" void EXTI1_IRQHandler(void)
{
    // FUCK THIS INTERRUPT!
    //EXTI->PR1 = 0x00001000;
    EXTI->PR1 = 0x00000002;
    __DSB();
    IntCount += 1;
}

extern "C" void EXTI1_IRQHandler_wut(void)
{
    // Clear Pending interrupt bit
    EXTI->PR1 = 2;

    GPIOA->MODER = 0xABFF5555;
    GPIOB->MODER = 0x5CB555B3;

    // Output the half word.
    uint32_t Value = (((ReadOffset & 2) == 0) ? PrefetchRead : (PrefetchRead >> 16));
    uint32_t OutB = (((Value >> 4) & 0x03F0) | (Value & 0xC000));
    GPIOA->ODR = (Value & 0xFF);
    GPIOB->ODR = OutB;
    ReadOffset += 2;
    if ((ReadOffset & 3) == 0) {
        //if ((ADInputAddress >= N64_ROM_BASE) && (ADInputAddress < (N64_ROM_BASE + (64 * 1024 * 1024)))) {
            PrefetchRead = *((uint32_t*)(ram + (ADInputAddress - N64_ROM_BASE) + ReadOffset));
        //}
    }

    //GPIOA->MODER &= 0xFFFF0008;
    if (ReadCount < (500000)) {
        LogBuffer[ReadCount] = ADInputAddress;
        ReadCount += 1;
    }


    if (ReadOffset == 512) {
        ReadOffset = 0;
    }
    // Wait for READ high and set the mode.
    //while ((GPIOC->IDR & 1) == 0) {}
    //GPIOA->MODER &= 0xFFFF0000;
    //GPIOB->MODER &= 0x0FF000FF;
    
    while (((GPIOC->IDR & (READ_LINE | ALE_L)) == 0)) {}
    __DSB();
    GPIOA->MODER = 0xABFF0000;
    GPIOB->MODER = 0x0CB000B3;
    //GPIOC->BSRR = 2 << 16;
    //}
}
#endif

void RunN64PI(void)
{
    while (ALE_H_IS_LOW) {}
    IntCount = OutCount;
    //DMACount = reads;
    while (1) {
        // Wait for ALE_L high. (spin while ALE_L low)
        while (ALE_L_IS_LOW) {
            if (IntCount != OutCount) {
                goto outputNow;
            }
        }

        // Read the high part of the address on ALE_L rising.
        HighB = GPIOB->IDR;
        HighA = GPIOA->IDR;
        //GPIOC->BSRR = 2;
        //uint32_t PIValue = (GPIOA->IDR & 0xFF) | ((NowB & 0x03F0) << 4) | (NowB & 0xC000);
        //ADInputAddress = (ADInputAddress & 0x0000FFFF) | ((0x0000FFFF & PIValue) << 16);

        // This can be avoided if the downward edge of ALE_L is caught.
        // Allthough Still need to wait on ALE_H-High.
        //while(DMACount == reads) {}

        // Wait for ALE_H to drop. Spin while ALE_H is high.
        while (ALE_H_IS_HIGH) {}
        LowB = GPIOB->IDR;
        LowA = GPIOA->IDR;

        //B[1] = GPIOB->IDR;
        //A[1] = GPIOA->IDR;
        //__DSB();
        //reads += 2;
        //ADInputAddress = (A[1] & 0xFF) | ((B[1] & 0x03F0) << 4) | (B[1] & 0xC000) |
        //                 (((A[0] & 0xFF) | ((B[0] & 0x03F0) << 4) | (B[0] & 0xC000)) << 16);

        //GPIOC->BSRR = 2 << 16;
        //PIValue = (GPIOA->IDR & 0xFF) | ((NowB & 0x03F0) << 4) | (NowB & 0xC000);
        // Read the low part of the address.
        ADInputAddress = (LowA & 0xFF) | ((LowB & 0x03F0) << 4) | (LowB & 0xC000) |
                         (((HighA & 0xFF) | ((HighB & 0x03F0) << 4) | (HighB & 0xC000)) << 16);
        //if ((ADInputAddress & 0xFFFF) == ((ADInputAddress >> 16) & 0xFFFF)) {
        //    ADInputAddress = (LogBuffer[ReadCount - 1] & 0xFFFF0000) | (ADInputAddress & 0xFFFF);
        //}
        //if ((ADInputAddress >= N64_ROM_BASE) && ((ADInputAddress - N64_ROM_BASE) < (64 * 1024 * 1024))) {
            PrefetchRead = *((uint32_t*)(ram + (ADInputAddress - N64_ROM_BASE)));
        //}

        ReadOffset = 0;
        while (IntCount == OutCount) {}
outputNow:
        GPIOA->MODER = 0xABFF5555;
        //GPIOB->MODER = 0x5CF555B3;
        GPIOB->MODER = 0x5CB555B3;
        while (1) {
            // Output the half word.
            uint32_t Value = (((ReadOffset & 2) == 0) ? PrefetchRead : (PrefetchRead >> 16));
            uint32_t OutB = (((Value >> 4) & 0x03F0) | (Value & 0xC000));

            GPIOA->ODR = (Value & 0xFF);
            GPIOB->ODR = OutB;
            if ((ReadOffset & 2) == 0) {
                LogBuffer[ReadCount] = ADInputAddress | (ReadOffset & 511);

            } else {
                LogBuffer[ReadCount] = PrefetchRead;
            }

            ReadOffset += 2;
            if ((ReadOffset & 3) == 0) {
                PrefetchRead = *((uint32_t*)(ram + (ADInputAddress - N64_ROM_BASE) + (ReadOffset & 511)));
            }

            if (ReadCount < ((8*1024*1024) / 4)) {
                ReadCount += 1;
            }

            OutCount += 1;
            if ((ReadOffset & 2) != 0) {
                while (IntCount == OutCount) {}
                continue;
            }

            //while(DMACount != reads) {
            //    // Something bad happened, we got a read interrupt before being able to set the mode correctly.
            //    GPIOC->BSRR = (1 << 7);
            //}

            // Wait for READ high and set the mode.
            while (READ_IS_LOW) {
                if (IntCount != OutCount) {
                    continue;
                }
            }
            break;
        }

        GPIOA->MODER = 0xABFF0000;
        //GPIOB->MODER = 0x0CF000B3;
        GPIOB->MODER = 0x0CB000B3;
    }
}

int main(void)
{
    size_t bytesread = 0;

    // Init hardware
    hw.Init(true);

    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_GPIOC_CLK_ENABLE();
    __HAL_RCC_GPIOD_CLK_ENABLE();
    __HAL_RCC_GPIOG_CLK_ENABLE();
    // Preconfigure GPIO PortA and PortB, so the following directional changes can be faster.
    GPIO_InitTypeDef PortAPins = {0xFF, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GP_SPEED, 0};
    GPIO_InitTypeDef PortBPins = {0xC3F0, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GP_SPEED, 0};
    HAL_GPIO_Init(GPIOA, &PortAPins);
    HAL_GPIO_Init(GPIOB, &PortBPins);
    
    PortAPins = {0xFF, GPIO_MODE_INPUT, GPIO_NOPULL, GP_SPEED, 0};
    PortBPins = {0xC3F0, GPIO_MODE_INPUT, GPIO_NOPULL, GP_SPEED, 0};
    HAL_GPIO_Init(GPIOA, &PortAPins);
    HAL_GPIO_Init(GPIOB, &PortBPins);

    PortBPins = {(1 << 1) | (1 << 12), GPIO_MODE_INPUT, GPIO_NOPULL, GP_SPEED, 0};
    HAL_GPIO_Init(GPIOB, &PortBPins);

    GPIO_InitTypeDef PortCPins = {(1 << 0) | (1 << 1), GPIO_MODE_INPUT, GPIO_NOPULL, GP_SPEED, 0};
    HAL_GPIO_Init(GPIOC, &PortCPins);

    PortCPins = {(1 << 7), GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GP_SPEED, 0};
    HAL_GPIO_Init(GPIOC, &PortCPins);

    GPIO_InitTypeDef PortDPins = {(1 << 11), GPIO_MODE_INPUT, GPIO_NOPULL, GP_SPEED, 0};
    HAL_GPIO_Init(GPIOD, &PortDPins);

    GPIO_InitTypeDef PortGPins = {(1 << 10) | (1 << 11), GPIO_MODE_INPUT, GPIO_NOPULL, GP_SPEED, 0};
    PortGPins.Pin |= (1 << 9);
    HAL_GPIO_Init(GPIOG, &PortGPins);

    GPIOC->ODR = (0x1 << 7);

    SdmmcHandler::Config sd_cfg;
    sd_cfg.Defaults();
    sd_cfg.speed = SdmmcHandler::Speed::STANDARD;
    {
        sd.Init(sd_cfg);

        // Links libdaisy i/o to fatfs driver.
        fsi.Init(FatFSInterface::Config::MEDIA_SD);

        // Mount SD Card
        if (f_mount(&fsi.GetSDFileSystem(), "/", 1) != FR_OK) {
            while(1) {
                GPIOC->BSRR = (0x1 << 7);
                System::Delay(500);
                GPIOC->BSRR = (0x1 << 7) << 16;
                System::Delay(100);
            }
        }

        // Open and write the test file to the SD Card.
        //if(f_open(&SDFile, MENU_ROM_FILE_NAME, (FA_CREATE_ALWAYS) | (FA_WRITE)) == FR_OK) {
        //    f_write(&SDFile, outbuff, len, &byteswritten);
        //    f_close(&SDFile);
        //}

        // Read the menu rom from the SD Card.
        if(f_open(&SDFile, MENU_ROM_FILE_NAME, FA_READ) == FR_OK) {
            FILINFO FileInfo;
            FRESULT result = f_stat(MENU_ROM_FILE_NAME, &FileInfo);
            if (result != FR_OK) {
                BlinkAndDie(100, 500);
            }
            result = f_read(&SDFile, ram, FileInfo.fsize, &bytesread);
            if (result != FR_OK) {
                BlinkAndDie(200, 200);
            }
            f_close(&SDFile);

            // Blink led on error.
            if (bytesread != FileInfo.fsize) {
                BlinkAndDie(500, 500);
            }
            //memset(ram, 0xFF, FileInfo.fsize);
        } else {
            BlinkAndDie(100, 100);
        }
    }
    // No led on on success.
    GPIOC->BSRR = (0x1 << 7) << 16;

    // Patch
    memcpy(ram, rawData, 16);
    SysTick->CTRL = 0;


    // ALEL interrupt setup. Needs to cause a DMA transaction. From Perih to Memory.
    

    // Read interrupt setup.
#ifdef DMA_SOLUTION
    GPIO_InitTypeDef GPIO_InitStruct;
#if 0 // Do not enable ALE interrupts.
    // ALEH interrupt setup. -- 
    // This interrupt is used only to indicate that ALE_H has fallen during ALE_L high and that the High oder WORD needs to be updated.
    GPIO_InitStruct = {ALE_H, GPIO_MODE_IT_FALLING, GPIO_NOPULL, GP_SPEED, 0};
    NVIC_SetVector(EXTI15_10_IRQn, (uint32_t)&EXTI15_10_IRQHandler);
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
    HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
#endif

    //NVIC_SetVector(EXTI1_IRQn, (uint32_t)&__EXTI0_IRQHandler);
    //LPTIM_Config();
    // Disable LP3 timer.
    //DISABLE_LP3_TIMER();
    //InitializeDmaChannels();

    GPIO_InitStruct = {ALE_L, GPIO_MODE_IT_RISING_FALLING, GPIO_NOPULL, GP_SPEED, 0};
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
    HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
    NVIC_SetVector(EXTI0_IRQn, (uint32_t)&EXTI0_IRQHandler);
    HAL_NVIC_EnableIRQ(EXTI0_IRQn);
    
    GPIO_InitStruct = {READ_LINE, GPIO_MODE_IT_FALLING, GPIO_NOPULL, GP_SPEED, 0};
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
    HAL_NVIC_SetPriority(EXTI1_IRQn, 1, 0);
    NVIC_SetVector(EXTI1_IRQn, (uint32_t)&EXTI1_IRQHandler);
    HAL_NVIC_EnableIRQ(EXTI1_IRQn);

    
#else
    //InitializeDmaChannels();
    //GPIO_InitTypeDef GPIO_InitStruct;
    //GPIO_InitStruct = {READ_LINE, GPIO_MODE_IT_FALLING, GPIO_NOPULL, GP_SPEED, 0};
    //HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
    //HAL_NVIC_SetPriority(EXTI1_IRQn, 0, 0);
    //NVIC_SetVector(EXTI1_IRQn, (uint32_t)&EXTI1_IRQHandler);
    //HAL_NVIC_EnableIRQ(EXTI1_IRQn);
    //GPIO_InitTypeDef GPIO_InitStruct;

    //while (ALE_H_IS_LOW) {}
    //daisy::System::tim_.Stop(); // Make sure to start this timer again when reading SD.
//
    //GPIO_InitTypeDef GPIO_InitStruct;
    //GPIO_InitStruct = {READ_LINE, GPIO_MODE_IT_FALLING, GPIO_PULLUP, GP_SPEED, 0};
    //HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
    //HAL_NVIC_SetPriority(EXTI1_IRQn, 0, 0);
    //NVIC_SetVector(EXTI1_IRQn, (uint32_t)&EXTI1_IRQHandler);
    //HAL_NVIC_EnableIRQ(EXTI1_IRQn);

    GPIO_InitTypeDef GPIO_InitStruct;
    //GPIO_InitStruct = {ALE_L, GPIO_MODE_IT_RISING_FALLING, GPIO_NOPULL, GP_SPEED, 0};
    //HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
    //HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
    //NVIC_SetVector(EXTI0_IRQn, (uint32_t)&EXTI0_IRQHandler);
    //HAL_NVIC_EnableIRQ(EXTI0_IRQn);

    GPIO_InitStruct = {READ_LINE, GPIO_MODE_IT_FALLING, GPIO_NOPULL, GP_SPEED, 0};
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
    HAL_NVIC_SetPriority(EXTI1_IRQn, 0, 0);
    NVIC_SetVector(EXTI1_IRQn, (uint32_t)&EXTI1_IRQHandler);
    HAL_NVIC_EnableIRQ(EXTI1_IRQn);
    
#endif

#if 0
    constexpr Pin D25 = Pin(PORTA, 0); // AD0  // Could be used for DMA
    constexpr Pin D24 = Pin(PORTA, 1); // AD1
    constexpr Pin D28 = Pin(PORTA, 2); // AD2  // Could be used for DMA
    constexpr Pin D16 = Pin(PORTA, 3); // AD3
    constexpr Pin D23 = Pin(PORTA, 4); // AD4
    constexpr Pin D22 = Pin(PORTA, 5); // AD5
    constexpr Pin D19 = Pin(PORTA, 6); // AD6
    constexpr Pin D18 = Pin(PORTA, 7); // AD7

    constexpr Pin D17 = Pin(PORTB, 1); // Write.
    constexpr Pin D9  = Pin(PORTB, 4); // AD8
    constexpr Pin D10 = Pin(PORTB, 5); // AD9
    constexpr Pin D13 = Pin(PORTB, 6); // AD10
    constexpr Pin D14 = Pin(PORTB, 7); // AD11
    constexpr Pin D11 = Pin(PORTB, 8); // AD12
    constexpr Pin D12 = Pin(PORTB, 9); // AD13
    constexpr Pin D0  = Pin(PORTB, 12); // N.C
    constexpr Pin D29 = Pin(PORTB, 14); // AD14
    constexpr Pin D30 = Pin(PORTB, 15); // AD15

    constexpr Pin D15 = Pin(PORTC, 0); // ALE_L -- // Read  // Could be used for DMA
    constexpr Pin D20 = Pin(PORTC, 1); // Read -- N.C -- Cold reset needs to be hooked up..
    constexpr Pin D21 = Pin(PORTC, 4); // S-DATA
    constexpr Pin D4  = Pin(PORTC, 8); // SD card D0
    constexpr Pin D3  = Pin(PORTC, 9); // SD card D1
    constexpr Pin D2  = Pin(PORTC, 10); // SD card D2
    constexpr Pin D1  = Pin(PORTC, 11); // SD card D3
    constexpr Pin D6  = Pin(PORTC, 12); // SD card CLK

    constexpr Pin D5  = Pin(PORTD, 2);  // SD card CMD  // Could be used for DMA
    constexpr Pin D26 = Pin(PORTD, 11); // ALE_H

    constexpr Pin D27 = Pin(PORTG, 9);  // CIC_D1
    constexpr Pin D7  = Pin(PORTG, 10); // CIC_D2
    constexpr Pin D8  = Pin(PORTG, 11); // N64_NMI
    // PORTC, 7 -- LED, NC -- Card Detect
    // PORTG, 14 NC -- S-CLK
    // 

            /**SDMMC1 GPIO Configuration    
            PC12     ------> SDMMC1_CK
            PC11     ------> SDMMC1_D3
            PC10     ------> SDMMC1_D2
            PD2     ------> SDMMC1_CMD
            PC9     ------> SDMMC1_D1
            PC8     ------> SDMMC1_D0 */
#endif

 
#if 0
    //Hack first read
    HighB = 0x100;
    HighA = 0x00;
    LowB = 0x0000;
    LowA = 0x00;
    ADInputAddress = N64_ROM_BASE;
    PrefetchRead = *((uint32_t*)(ram + (ADInputAddress - N64_ROM_BASE)));

    while (ALE_L_IS_LOW) {} // Wait for ALE_L HIGH
    while (ALE_H_IS_HIGH) {} // Wait for ALE_H LOW

    while (READ_IS_HIGH) {}
    GPIOA->MODER = 0xABFF5555;
    GPIOB->MODER = 0x5CB555B3;

start_word1:

    // Output the half word.
    uint32_t Value = (((ReadOffset & 2) == 0) ? PrefetchRead : (PrefetchRead >> 16));
    uint32_t OutB = (((Value >> 4) & 0x03F0) | (Value & 0xC000));
    GPIOA->ODR = (Value & 0xFF);
    GPIOB->ODR = OutB;
    ReadOffset += 2;
    if ((ReadOffset & 3) == 0) {
        //if ((ADInputAddress >= N64_ROM_BASE) && (ADInputAddress < (N64_ROM_BASE + (64 * 1024 * 1024)))) {
            PrefetchRead = *((uint32_t*)(ram + (ADInputAddress - N64_ROM_BASE) + ReadOffset));
        //}
    }

    //GPIOA->MODER &= 0xFFFF0008;
    LogBuffer[ReadCount] = ADInputAddress;
    ReadCount += 1;


    if (ReadOffset == 512) {
        ReadOffset = 0;
    }

    // Wait for READ high and set the mode.
    //while ((GPIOC->IDR & 1) == 0) {}
    //GPIOA->MODER &= 0xFFFF0000;
    //GPIOB->MODER &= 0x0FF000FF;
    
    if ((ReadOffset & 3) != 0) {
        volatile uint32_t wait = 40*10;
        while (wait--) {}
        goto start_word1;
    }

    while (((GPIOC->IDR & (READ_LINE)) == 0)) {}
    GPIOA->MODER = 0xABFF0000;
    GPIOB->MODER = 0x0CB000B3;

    // Interrupt should happen here.
    // Wait for ALE_H high.
    while (ALE_H_IS_LOW) {}
#endif
    //PortAPins = {0x01, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GP_SPEED, 0};
    //HAL_GPIO_Init(GPIOA, &PortAPins);
#if DMA_SOLUTION
    while (1) {
        // Main loop of nothing.
    }
#else
    RunN64PI();
#endif
}